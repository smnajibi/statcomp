\documentclass[8pt,ignorenonframetext,]{beamer}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\beamertemplatenavigationsymbolsempty
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
\usetheme[]{SDATbeamer}
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\newif\ifbibliography
\hypersetup{
            pdftitle={Lecture 3: Data Frames and Control},
            pdfauthor={S. Morteza Najibi},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}

% Prevent slide breaks in the middle of a paragraph:
\widowpenalties 1 10000
\raggedbottom

\AtBeginPart{
  \let\insertpartnumber\relax
  \let\partname\relax
  \frame{\partpage}
}
\AtBeginSection{
  \ifbibliography
  \else
    \let\insertsectionnumber\relax
    \let\sectionname\relax
    \frame{\sectionpage}
  \fi
}
\AtBeginSubsection{
  \let\insertsubsectionnumber\relax
  \let\subsectionname\relax
  \frame{\subsectionpage}
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\title{Lecture 3: Data Frames and Control}
\author{S. Morteza Najibi}
\date{February 27, 2019}

\begin{document}
\frame{\titlepage}

\begin{frame}{Agenda}

\begin{itemize}
\tightlist
\item
  Making and working with data frames
\item
  Conditionals: switching between different calculations
\item
  Iteration: Doing something over and over
\item
  Vectorizing: Avoiding explicit iteration
\end{itemize}

\end{frame}

\begin{frame}[fragile]{In Our Last Thrilling Episode}

\begin{itemize}
\tightlist
\item
  Vectors: series of values all of the same type\\
  \texttt{v{[}5{]}}, `v{[}``name''{]}
\item
  Arrays: multi-dimensional generalization of vectors
  \texttt{a{[}5,6,2{]}}, \texttt{a{[},6,{]}},
  \texttt{a{[}rowname,\ colname,\ layername{]}}
\item
  Matrices: special 2D arrays with matrix math\\
  \texttt{m{[}5,6{]}}, \texttt{m{[},6{]}}, \texttt{m{[},colname{]}}
\item
  Lists: series of values of mixed types\\
  \texttt{l{[}{[}3{]}{]}}, \texttt{l\$name}
\item
  Dataframes: hybrid of matrix and list
\end{itemize}

\end{frame}

\begin{frame}{Dataframes, Encore}

\begin{itemize}
\tightlist
\item
  2D tables of data
\item
  Each case/unit is a row
\item
  Each variable is a column
\item
  Variables can be of any type (numbers, text, Booleans, \ldots{})
\item
  Both rows and columns can get names
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Creating an example dataframe}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(datasets)}
\NormalTok{states <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(state.x77, }\DataTypeTok{abb=}\NormalTok{state.abb, }\DataTypeTok{region=}\NormalTok{state.region, }\DataTypeTok{division=}\NormalTok{state.division)}
\end{Highlighting}
\end{Shaded}

\texttt{data.frame()} is combining here a pre-existing matrix
(\texttt{state.x77}), a vector of characters (\texttt{state.abb}), and
two vectors of qualitative categorical variables (\textbf{factors};
\texttt{state.region}, \texttt{state.division})

Column names are preserved or guessed if not explicitly set

\end{frame}

\begin{frame}[fragile]{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{colnames}\NormalTok{(states)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "Population" "Income"     "Illiteracy" "Life.Exp"   "Murder"    
 [6] "HS.Grad"    "Frost"      "Area"       "abb"        "region"    
[11] "division"  
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{states[}\DecValTok{1}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
        Population Income Illiteracy Life.Exp Murder HS.Grad Frost  Area
Alabama       3615   3624        2.1    69.05   15.1    41.3    20 50708
        abb region           division
Alabama  AL  South East South Central
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Dataframe access}

\begin{itemize}
\tightlist
\item
  By row and column index
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{states[}\DecValTok{49}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.7
\end{verbatim}

\begin{itemize}
\tightlist
\item
  By row and column names
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{states[}\StringTok{"Wisconsin"}\NormalTok{,}\StringTok{"Illiteracy"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.7
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Dataframe access (cont'd)}

\begin{itemize}
\tightlist
\item
  All of a row:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{states[}\StringTok{"Wisconsin"}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
          Population Income Illiteracy Life.Exp Murder HS.Grad Frost  Area
Wisconsin       4589   4468        0.7    72.48      3    54.5   149 54464
          abb        region           division
Wisconsin  WI North Central East North Central
\end{verbatim}

Exercise: what class is \texttt{states{[}"Wisconsin",{]}}?

\end{frame}

\begin{frame}[fragile]{Dataframe access (cont'd.)}

\begin{itemize}
\tightlist
\item
  All of a column:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(states[,}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.1 1.5 1.8 1.9 1.1 0.7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(states[,}\StringTok{"Illiteracy"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.1 1.5 1.8 1.9 1.1 0.7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(states}\OperatorTok{$}\NormalTok{Illiteracy)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2.1 1.5 1.8 1.9 1.1 0.7
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Dataframe access (cont'd.)}

\begin{itemize}
\tightlist
\item
  Rows matching a condition:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{states[states}\OperatorTok{$}\NormalTok{division}\OperatorTok{==}\StringTok{"New England"}\NormalTok{, }\StringTok{"Illiteracy"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1.1 0.7 1.1 0.7 1.3 0.6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{states[states}\OperatorTok{$}\NormalTok{region}\OperatorTok{==}\StringTok{"South"}\NormalTok{, }\StringTok{"Illiteracy"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 2.1 1.9 0.9 1.3 2.0 1.6 2.8 0.9 2.4 1.8 1.1 2.3 1.7 2.2 1.4 1.4
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Replacing values}

Parts or all of the dataframe can be assigned to:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(states}\OperatorTok{$}\NormalTok{HS.Grad)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  37.80   48.05   53.25   53.11   59.15   67.30 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{states}\OperatorTok{$}\NormalTok{HS.Grad <-}\StringTok{ }\NormalTok{states}\OperatorTok{$}\NormalTok{HS.Grad}\OperatorTok{/}\DecValTok{100}
\KeywordTok{summary}\NormalTok{(states}\OperatorTok{$}\NormalTok{HS.Grad)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.3780  0.4805  0.5325  0.5311  0.5915  0.6730 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{states}\OperatorTok{$}\NormalTok{HS.Grad <-}\StringTok{ }\DecValTok{100}\OperatorTok{*}\NormalTok{states}\OperatorTok{$}\NormalTok{HS.Grad}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}[fragile]{with()}

What percentage of literate adults graduated HS?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(}\DecValTok{100}\OperatorTok{*}\NormalTok{(states}\OperatorTok{$}\NormalTok{HS.Grad}\OperatorTok{/}\NormalTok{(}\DecValTok{100}\OperatorTok{-}\NormalTok{states}\OperatorTok{$}\NormalTok{Illiteracy)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 42.18590 67.71574 59.16497 40.67278 63.29626 64.35045
\end{verbatim}

\texttt{with()} takes a data frame and evaluates an expression
``inside'' it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with}\NormalTok{(states, }\KeywordTok{head}\NormalTok{(}\DecValTok{100}\OperatorTok{*}\NormalTok{(HS.Grad}\OperatorTok{/}\NormalTok{(}\DecValTok{100}\OperatorTok{-}\NormalTok{Illiteracy))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 42.18590 67.71574 59.16497 40.67278 63.29626 64.35045
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Data arguments}

Lots of functions take \texttt{data} arguments, and look variables up in
that data frame:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(Illiteracy}\OperatorTok{~}\NormalTok{Frost, }\DataTypeTok{data=}\NormalTok{states)}
\end{Highlighting}
\end{Shaded}

\(R^2 =0.45\), \(p \approx {10}^{-7}\)

\end{frame}

\begin{frame}[fragile]{Conditionals}

Have the computer decide what to do next - Mathematically: \[
|x| = \left\{ \begin{array}{cl} x & \mathrm{if}~x\geq 0 \\
-x &\mathrm{if}~ x < 0\end{array}\right. ~,~ 
\psi(x) = \left\{ \begin{array}{cl} x^2 & \mathrm{if}~|x|\leq 1\\
2|x|-1 &\mathrm{if}~ |x| > 1\end{array}\right.
\]\\
Exercise: plot \(\psi\) in R - Computationally:

\begin{verbatim}
if the country code is not "US", multiply prices by current exchange rate
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{if()}

Simplest conditional:

\begin{verbatim}
if (x >= 0) {
  x
} else {
  -x
}
\end{verbatim}

Condition in \texttt{if} needs to give \emph{one} \texttt{TRUE} or
\texttt{FALSE} value

\texttt{else} clause is optional

one-line actions don't need braces

\begin{verbatim}
if (x >= 0) x else -x
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Nested if()}

\texttt{if} can \emph{nest} arbitrarily deeply:

\begin{verbatim}
if (x^2 < 1) {
  x^2
} else {
  if (x >= 0) {
    2*x-1
  } else {
     -2*x-1
  }
}
\end{verbatim}

Can get ugly though

\end{frame}

\begin{frame}[fragile]{Combining Booleans: \&\& and
\textbar{}\textbar{}}

\texttt{\&} work \texttt{\textbar{}} like \texttt{+} or \texttt{*}:
combine terms element-wise

Flow control wants \emph{one} Boolean value, and to skip calculating
what's not needed

\texttt{\&\&} and \texttt{\textbar{}\textbar{}} give \emph{one} Boolean,
lazily:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{0} \OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) }\OperatorTok{&&}\StringTok{ }\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(}\DecValTok{42}\OperatorTok{%%}\DecValTok{6}\NormalTok{, }\DecValTok{169}\OperatorTok{%%}\DecValTok{13}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

This \emph{never} evaluates the complex expression on the right

Use \texttt{\&\&} and \texttt{\textbar{}\textbar{}} for control,
\texttt{\&} and \texttt{\textbar{}} for subsetting

\end{frame}

\begin{frame}[fragile]{Iteration}

Repeat similar actions multiple times:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{table.of.logarithms <-}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\DataTypeTok{length=}\DecValTok{7}\NormalTok{,}\DataTypeTok{mode=}\StringTok{"numeric"}\NormalTok{)}
\NormalTok{table.of.logarithms}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0 0 0 0 0 0 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(table.of.logarithms)) \{}
\NormalTok{  table.of.logarithms[i] <-}\StringTok{ }\KeywordTok{log}\NormalTok{(i)}
\NormalTok{\}}
\NormalTok{table.of.logarithms}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{for()}

\begin{verbatim}
for (i in 1:length(table.of.logarithms)) {
  table.of.logarithms[i] <- log(i)
}
\end{verbatim}

\texttt{for} increments a \textbf{counter} (here \texttt{i}) along a
vector (here \texttt{1:length(table.of.logarithms)}) and \textbf{loops
through} the **body* until it runs through the vector

``\textbf{iterates over} the vector''

N.B., there is a better way to do this job!

\end{frame}

\begin{frame}{The body of the for() loop}

Can contain just about anything, including: - if() clauses - other for()
loops (nested iteration)

\end{frame}

\begin{frame}[fragile]{Nested iteration example}

\begin{verbatim}
c <- matrix(0, nrow=nrow(a), ncol=ncol(b))
if (ncol(a) == nrow(b)) {
  for (i in 1:nrow(c)) {
    for (j in 1:ncol(c)) {
      for (k in 1:ncol(a)) {
        c[i,j] <- c[i,j] + a[i,k]*b[k,j]
      }
    }
  }
} else {
  stop("matrices a and b non-conformable")
}
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{while(): conditional iteration}

\begin{verbatim}
while (max(x) - 1 > 1e-06) {
  x <- sqrt(x)
}
\end{verbatim}

Condition in the argument to \texttt{while} must be a single Boolean
value (like \texttt{if})

Body is looped over until the condition is \texttt{FALSE} so can loop
forever

Loop never begins unless the condition starts \texttt{TRUE}

\end{frame}

\begin{frame}{for() vs.~while()}

for() is better when the number of times to repeat (values to iterate
over) is clear in advance

while() is better when you can recognize when to stop once you're there,
even if you can't guess it to begin with

Every for() could be replaced with a while()\\
Exercise: show this

\end{frame}

\begin{frame}{Avoiding iteration}

R has many ways of \emph{avoiding} iteration, by acting on whole objects
- It's conceptually clearer - It leads to simpler code - It's faster
(sometimes a little, sometimes drastically)

\end{frame}

\begin{frame}[fragile]{Vectorized arithmetic}

How many languages add 2 vectors:

\begin{verbatim}
c <- vector(length(a))
for (i in 1:length(a)) {  c[i] <- a[i] + b[i]  }
\end{verbatim}

How R adds 2 vectors:

\begin{verbatim}
a+b
\end{verbatim}

or a triple \texttt{for()} loop for matrix multiplication vs.
\texttt{a\ \%*\%\ b}

\end{frame}

\begin{frame}{Advantages of vectorizing}

\begin{itemize}
\tightlist
\item
  Clarity: the syntax is about \emph{what} we're doing
\item
  Concision: we write less
\item
  Abstraction: the syntax hides \emph{how the computer does it}
\item
  Generality: same syntax works for numbers, vectors, arrays, \ldots{} -
  Speed: modifying big vectors over and over is slow in R; work gets
  done by optimized low-level code
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Vectorized calculations}

Many functions are set up to vectorize automatically

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abs}\NormalTok{(}\OperatorTok{-}\DecValTok{3}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3 2 1 0 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101
\end{verbatim}

See also \texttt{apply()} from last week

We'll come back to this in great detail later

\end{frame}

\begin{frame}[fragile]{Vectorized conditions: ifelse()}

\begin{verbatim}
ifelse(x^2 > 1, 2*abs(x)-1, x^2)
\end{verbatim}

1st argument is a Boolean vector, then pick from the 2nd or 3rd vector
arguments as \texttt{TRUE} or \texttt{FALSE}

\end{frame}

\begin{frame}[fragile]{Summary}

\begin{itemize}
\tightlist
\item
  Dataframes
\item
  \texttt{if}, nested \texttt{if}, \texttt{switch}
\item
  Iteration: \texttt{for}, \texttt{while}
\item
  Avoiding iteration with whole-object (``vectorized'') operations
\end{itemize}

\end{frame}

\begin{frame}[fragile]{What Is Truth?}

0 counts as \texttt{FALSE}; other numeric values count as \texttt{TRUE};
the strings ``TRUE'' and ``FALSE'' count as you'd hope; most everything
else gives an error

Advice: Don't play games here; try to make sure control expressions are
getting Boolean values

Conversely, in arithmetic, \texttt{FALSE} is 0 and \texttt{TRUE} is 1

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(states}\OperatorTok{$}\NormalTok{Murder }\OperatorTok{>}\StringTok{ }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.48
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{switch()}

Simplify nested \texttt{if} with \texttt{switch()}: give a variable to
select on, then a value for each option

\begin{verbatim}
switch(type.of.summary,
       mean=mean(states$Murder),
       median=median(states$Murder),
       histogram=hist(states$Murder),
       "I don't understand")
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{Exercise (off-line)}

Set \texttt{type.of.summary} to, succesively, ``mean'', ``median'',
``histogram'', and ``mode'', and explain what happens

\end{frame}

\begin{frame}[fragile]{Unconditional iteration}

\begin{verbatim}
repeat {
  print("Help! I am Dr. Morris Culpepper, trapped in an endless loop!")
}
\end{verbatim}

\end{frame}

\begin{frame}[fragile]{``Manual'' control over iteration}

\begin{verbatim}
repeat {
  if (watched) { next() }
  print("Help! I am Dr. Morris Culpepper, trapped in an endless loop!")
  if (rescued) { break() }
}
\end{verbatim}

\texttt{break()} exits the loop; \texttt{next()} skips the rest of the
body and goes back into the loop

both work with \texttt{for()} and \texttt{while()} as well

Exercise: how would you replace \texttt{while()} with \texttt{repeat()}?

\end{frame}

\end{document}
